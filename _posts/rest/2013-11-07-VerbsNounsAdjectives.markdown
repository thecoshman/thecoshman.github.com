##Let's talk HTTP
As I said in previous articles, REST should not automatically imply HTTP; for this article, however, I will concede that REST is almost always implemented over HTTP. And whilst I am getting confessions out of the way: adjectives are not a part of this article. This article is going to look at the 'verbs' of HTTP, otherwise known as the 'methods'. The nouns are just the resources on which a user calls methods. An HTTP request contains a verb for what they want to do, along with a URI to say on what noun you want to do this action.
HTTP1.0 got the ball rolling with three methods; GET, POST and HEAD. HTTP1.1 introduced five more: OPTIONS, PUT, DELETE, TRACE and CONNECT. That's it; as far as RFC2616 is concerned there are only eight types of request to make all the magic work. Well, not exactly, as the protocol does allow for a server to accept other methods. It also fails to support what I would consider a rather 'normal' task, but I will leave you in suspense about that until later.
##Dissection Time
Before I start explaining what the HTTP methods mean and how they are intended to be used I shall cover the concept of 'safe' and 'idempotent' methods. A method is considered 'safe' if it does not cause any visible side effects on the server. A GET method is a fine example of this; when a user GETs a resource they should not expect (to be able to observe) anything changing on the server beyond them being sent the resource they requested. The server is not forbidden from making changes, such as logging that user X requested resource Y, but no such change should be visible to the user. The user should feel safe to make 'safe' request knowing that they are not about to see some other resource deleted or modified. The specification emphasizes that methods that are not safe should be presented by the user agent as significant; If the user asks to GET a resource, just go for it, all that should do is retrieve the resource; but if the user wants to DELETE a resource you had best make sure because that is not 'safe'.
Idempotent methods are 'those that have the property of idempotence', which seem like the specification is saying "hot things are hot". In laymen's terms, idempotent methods would be ones that produce identical results if they are repeated. Again, GET is a good example, no matter how many times you GET a single resource, the result is the same. DELETE is also considered idempotent. Although you can only actually delete the resource once, the actual effect of one or more DELETEs is the same: the resource no longer exists. According to the specification it is possible, though I do struggle think how, that a series of idempotent requests is not itself idempotent.
For the sake of brevity and keeping focused on the methods themselves, I will refrain from talking about all the other things that a server could respond with, like authentication requests.
##GET
The GET method is a straight forward method to understand. It is both safe and idempotent. A client will 'GET' a URI and the server will respond with the resource. There is potential for a client to indicate in the headers how they want the resource presented, xml of json for example. Along with the resource, the server can provide some metadata, such as how to interpret the resource.
Usually, there would be no need for a client’s GET request to contain a body. Why would you need such a body in a GET request; can you even do that? For most situations, you wouldn't, but the fact that you can at all seems often overlooked. If your GET request is just trying to get one static resource from one URI, there is not much more that the request needs to say (beyond what the header would be used for). It can be very useful when the URI is used to access 'dynamic data' though—for example if you want to GET search results or multiple 'things'. A common solution to providing 'metadata' for a GET request is to use a 'query' string at the end of the URI. Query strings can look ugly and can be difficult to manage when dealing with complex data sets, so it is nice to have the request body as an alternative. I'm not advocating either way, your application will dictate what makes the most sense.
##POST
The POST method is used to store a 'thing' on the server 'somewhere' - fuzzy I know, but sit tight. Obviously this method is not safe, that would imply that once a 'thing' was POSTed to the server a client could never see it, and so POSTed that 'thing' for no reason. Neither is this method idempotent, every time a client POSTs a 'thing' to a server, it should return a new URI that can be used to GET that 'thing' back again (in some form).
I keep saying 'thing' because there really is no limit on what the client can send to the server, nor what the server then does with that. A client could POST some data in XML, which the server could then process and store in a relational data base and offer a URI that can retrieve this new data in some bespoke format Of course, the server is under no obligation to actually store what it is sent (such as if the URI does not accept POST requests), but when it does store what it is sent, it should be telling the client where it is stored. You also need to consider that the URI assigned by the server to retrieve a particular piece of data is entirely arbitrary. 
##HEAD
A HEAD request is nearly identical to a GET request, except the server should reply with only the header information (but no body) that it would send in response to an otherwise identical GET request. I can only guess that in the early days when HTTP was being thought up, it was useful to have some sort of 'probe'. Perhaps it was useful to be able to see if a resource was still at a URI without having to actually transfer it. Just like GET, this is safe and idempotent. I wouldn't go as far as to say you shouldn't use this method at all, but I doubt you will have much use for it.
##The Bail Out
That covers the three verbs available in HTTP 1.0. I shall tackle the methods introduced by HTTP 1.1 next time.
